{
  "model": "deepseek/deepseek-chat-v3",
  "prompt_type": "stepwise_cot",
  "system_prompt": "You are an expert programmer. For each problem, follow this step-by-step reasoning process:\n\nSTEP 1 - UNDERSTAND: Read the problem carefully\n- What are the inputs and outputs?\n- What do the examples show?\n- What are the constraints?\n\nSTEP 2 - PLAN: Design your solution\n- What algorithm or approach should you use?\n- What data structures do you need?\n- What's the time/space complexity?\n\nSTEP 3 - EDGE CASES: Identify special cases\n- Empty inputs, single elements, duplicates\n- Boundary values (0, negative, maximum)\n- Invalid or unusual inputs\n\nSTEP 4 - IMPLEMENT: Write clean, correct code\n- Handle all edge cases\n- Use clear variable names\n- Ensure logic is sound\n\nEXAMPLE - Problem: Find the sum of all even numbers in a list\n{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a list of integers, output is a single integer (the sum). Need to identify even numbers (divisible by 2) and add them together. Example: [1,2,3,4] \u2192 2+4 = 6. STEP 2 - PLAN: Use a filtering approach - iterate through the list, check each number with modulo operator (n % 2 == 0), sum the filtered results. Can use generator expression with sum() for clean implementation. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0 (sum of nothing). No even numbers \u2192 return 0. All even numbers \u2192 sum all. List with zero \u2192 0 is even, include it. Negative evens \u2192 -2, -4 are even, include them. STEP 4 - IMPLEMENT: Use sum() with generator expression for clarity. The condition 'n % 2 == 0' handles all cases including negatives and zero correctly.\",\n  \"name\": \"sum_evens\",\n  \"code\": \"def sum_evens(numbers):\n    return sum(n for n in numbers if n % 2 == 0)\"\n}\n\nAfter your reasoning, output ONLY this JSON format (no markdown fences, no extra text):\n{\n  \"thinking\": \"<your step-by-step reasoning>\",\n  \"name\": \"<function_name>\",\n  \"code\": \"<complete_python_function_code_only>\"\n\n\nCRITICAL: The \"code\" field must contain ONLY the function code, no thinking or comments.",
  "tests": {
    "HumanEval/129": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a grid (NxN) and an integer k. We need to find the lexicographically smallest path of length k by moving to adjacent cells. The path can revisit cells. The output is a list of values along this path. Examples show that for k=3, the path [1,2,1] is smaller than [1,2,3]. For k=1, the smallest value is chosen. STEP 2 - PLAN: Use BFS to explore all possible paths of length k. At each step, prioritize paths that are lexicographically smaller. Use a priority queue (heap) to always expand the smallest path first. Track visited cells and their values. Time complexity: O(N^2 * k * log(N^2)), Space: O(N^2 * k). STEP 3 - EDGE CASES: k=1 \u2192 return the smallest value in the grid. k=N*N \u2192 return the sorted grid values. Grid with all values equal \u2192 any path is valid. STEP 4 - IMPLEMENT: Use a heap to store paths sorted lexicographically. For each step, expand the smallest path by moving to adjacent cells. Stop when a path of length k is found.",
      "name": "minPath",
      "code": "import heapq\ndef minPath(grid, k):\n    n = len(grid)\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\n    return []",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a grid (NxN) and an integer k. We need to find the lexicographically smallest path of length k by moving to adjacent cells. The path can revisit cells. The output is a list of values along this path. Examples show that for k=3, the path [1,2,1] is smaller than [1,2,3]. For k=1, the smallest value is chosen. STEP 2 - PLAN: Use BFS to explore all possible paths of length k. At each step, prioritize paths that are lexicographically smaller. Use a priority queue (heap) to always expand the smallest path first. Track visited cells and their values. Time complexity: O(N^2 * k * log(N^2)), Space: O(N^2 * k). STEP 3 - EDGE CASES: k=1 \u2192 return the smallest value in the grid. k=N*N \u2192 return the sorted grid values. Grid with all values equal \u2192 any path is valid. STEP 4 - IMPLEMENT: Use a heap to store paths sorted lexicographically. For each step, expand the smallest path by moving to adjacent cells. Stop when a path of length k is found.\",\n  \"name\": \"minPath\",\n  \"code\": \"import heapq\\ndef minPath(grid, k):\\n    n = len(grid)\\n    heap = []\\n    for i in range(n):\\n        for j in range(n):\\n            heapq.heappush(heap, ([grid[i][j]], i, j))\\n    while heap:\\n        path, x, y = heapq.heappop(heap)\\n        if len(path) == k:\\n            return path\\n        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n            nx, ny = x + dx, y + dy\\n            if 0 <= nx < n and 0 <= ny < n:\\n                heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\\n    return []\"\n}"
    },
    "HumanEval/69": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a non-empty list of positive integers. The output is the greatest integer that is greater than zero and has a frequency greater than or equal to its value. If no such integer exists, return -1. Examples show that we need to count the frequency of each number and find the largest number where frequency >= number. STEP 2 - PLAN: Use a frequency counter (dictionary) to count occurrences of each number. Iterate through the dictionary to find numbers where frequency >= number. Track the maximum such number. Time: O(n) for counting, O(m) for checking, where m is the number of unique elements. Space: O(m) for the dictionary. STEP 3 - EDGE CASES: Single element list \u2192 return 1 if frequency >= 1. All elements are the same \u2192 return the element if frequency >= element. No valid number \u2192 return -1. STEP 4 - IMPLEMENT: Use collections.Counter for frequency counting. Iterate through the counter to find the maximum valid number.",
      "name": "search",
      "code": "from collections import Counter\ndef search(lst):\n    freq = Counter(lst)\n    max_num = -1\n    for num, count in freq.items():\n        if count >= num and num > max_num:\n            max_num = num\n    return max_num",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a non-empty list of positive integers. The output is the greatest integer that is greater than zero and has a frequency greater than or equal to its value. If no such integer exists, return -1. Examples show that we need to count the frequency of each number and find the largest number where frequency >= number. STEP 2 - PLAN: Use a frequency counter (dictionary) to count occurrences of each number. Iterate through the dictionary to find numbers where frequency >= number. Track the maximum such number. Time: O(n) for counting, O(m) for checking, where m is the number of unique elements. Space: O(m) for the dictionary. STEP 3 - EDGE CASES: Single element list \u2192 return 1 if frequency >= 1. All elements are the same \u2192 return the element if frequency >= element. No valid number \u2192 return -1. STEP 4 - IMPLEMENT: Use collections.Counter for frequency counting. Iterate through the counter to find the maximum valid number.\",\n  \"name\": \"search\",\n  \"code\": \"from collections import Counter\\ndef search(lst):\\n    freq = Counter(lst)\\n    max_num = -1\\n    for num, count in freq.items():\\n        if count >= num and num > max_num:\\n            max_num = num\\n    return max_num\"\n}"
    },
    "HumanEval/141": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a string representing a file name. The output is 'Yes' if the file name is valid, otherwise 'No'. The conditions for validity are: no more than three digits, exactly one dot, the part before the dot is non-empty and starts with a letter, and the part after the dot is one of ['txt', 'exe', 'dll']. Examples show that 'example.txt' is valid, but '1example.dll' is not. STEP 2 - PLAN: Split the file name into two parts using the dot. Check the count of digits in the entire name. Ensure there is exactly one dot. Validate the prefix starts with a letter and is non-empty. Validate the suffix is one of the allowed extensions. Use string methods like count(), split(), isalpha(), and in operator. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: No dot \u2192 invalid. Multiple dots \u2192 invalid. Empty prefix \u2192 invalid. Prefix starts with a digit \u2192 invalid. Suffix not in allowed list \u2192 invalid. More than three digits \u2192 invalid. STEP 4 - IMPLEMENT: Implement the checks in order, ensuring all conditions are met before returning 'Yes'.",
      "name": "file_name_check",
      "code": "def file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.')\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n    return 'Yes'",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a string representing a file name. The output is 'Yes' if the file name is valid, otherwise 'No'. The conditions for validity are: no more than three digits, exactly one dot, the part before the dot is non-empty and starts with a letter, and the part after the dot is one of ['txt', 'exe', 'dll']. Examples show that 'example.txt' is valid, but '1example.dll' is not. STEP 2 - PLAN: Split the file name into two parts using the dot. Check the count of digits in the entire name. Ensure there is exactly one dot. Validate the prefix starts with a letter and is non-empty. Validate the suffix is one of the allowed extensions. Use string methods like count(), split(), isalpha(), and in operator. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: No dot \u2192 invalid. Multiple dots \u2192 invalid. Empty prefix \u2192 invalid. Prefix starts with a digit \u2192 invalid. Suffix not in allowed list \u2192 invalid. More than three digits \u2192 invalid. STEP 4 - IMPLEMENT: Implement the checks in order, ensuring all conditions are met before returning 'Yes'.\",\n  \"name\": \"file_name_check\",\n  \"code\": \"def file_name_check(file_name):\\n    if file_name.count('.') != 1:\\n        return 'No'\\n    prefix, suffix = file_name.split('.')\\n    if not prefix or not prefix[0].isalpha():\\n        return 'No'\\n    if suffix not in ['txt', 'exe', 'dll']:\\n        return 'No'\\n    if sum(c.isdigit() for c in file_name) > 3:\\n        return 'No'\\n    return 'Yes'\"\n}"
    },
    "HumanEval/94": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a list of integers. The task is to find the largest prime number in the list and return the sum of its digits. Examples show that the largest prime is identified first, then its digits are summed. STEP 2 - PLAN: First, create a helper function to check if a number is prime. Then, iterate through the list to find the largest prime. Finally, sum the digits of this prime. Time complexity: O(n * sqrt(m)) where n is the list length and m is the largest number in the list. Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0. No primes \u2192 return 0. Single prime \u2192 return sum of its digits. Multiple primes \u2192 choose the largest. Negative numbers \u2192 ignore since primes are positive. STEP 4 - IMPLEMENT: Implement the helper function to check for primes. Use a loop to find the largest prime in the list. Sum its digits by converting it to a string and summing each character as an integer.",
      "name": "skjkasdkd",
      "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    largest_prime = 0\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n    return sum(int(digit) for digit in str(largest_prime)) if largest_prime else 0",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a list of integers. The task is to find the largest prime number in the list and return the sum of its digits. Examples show that the largest prime is identified first, then its digits are summed. STEP 2 - PLAN: First, create a helper function to check if a number is prime. Then, iterate through the list to find the largest prime. Finally, sum the digits of this prime. Time complexity: O(n * sqrt(m)) where n is the list length and m is the largest number in the list. Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0. No primes \u2192 return 0. Single prime \u2192 return sum of its digits. Multiple primes \u2192 choose the largest. Negative numbers \u2192 ignore since primes are positive. STEP 4 - IMPLEMENT: Implement the helper function to check for primes. Use a loop to find the largest prime in the list. Sum its digits by converting it to a string and summing each character as an integer.\",\n  \"name\": \"skjkasdkd\",\n  \"code\": \"def skjkasdkd(lst):\\n    def is_prime(n):\\n        if n < 2:\\n            return False\\n        for i in range(2, int(n ** 0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n    largest_prime = 0\\n    for num in lst:\\n        if is_prime(num) and num > largest_prime:\\n            largest_prime = num\\n    return sum(int(digit) for digit in str(largest_prime)) if largest_prime else 0\"\n}"
    },
    "HumanEval/153": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a class name (string) and a list of extensions (strings). The output is a string combining the class name and the strongest extension, separated by a dot. The strength of an extension is calculated as (number of uppercase letters) - (number of lowercase letters). If multiple extensions have the same strength, choose the first one. Example: 'Slices.SErviNGSliCes' is returned for the input 'Slices' and ['SErviNGSliCes', 'Cheese', 'StuFfed']. STEP 2 - PLAN: Iterate through the extensions, calculate the strength for each, keep track of the maximum strength and the corresponding extension. Use a loop and helper functions to count uppercase and lowercase letters. Time: O(n*m) where n is the number of extensions and m is the average length of extensions. Space: O(1). STEP 3 - EDGE CASES: Empty extensions list \u2192 return class name with no extension. Extensions with equal strength \u2192 choose the first one. Extensions with all uppercase or all lowercase letters \u2192 handle correctly. STEP 4 - IMPLEMENT: Use a loop to iterate through extensions, calculate strength using helper functions, and keep track of the strongest extension.",
      "name": "Strongest_Extension",
      "code": "def Strongest_Extension(class_name, extensions):\n    if not extensions:\n        return class_name\n    max_strength = -float('inf')\n    strongest = ''\n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest = ext\n    return f'{class_name}.{strongest}'",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a class name (string) and a list of extensions (strings). The output is a string combining the class name and the strongest extension, separated by a dot. The strength of an extension is calculated as (number of uppercase letters) - (number of lowercase letters). If multiple extensions have the same strength, choose the first one. Example: 'Slices.SErviNGSliCes' is returned for the input 'Slices' and ['SErviNGSliCes', 'Cheese', 'StuFfed']. STEP 2 - PLAN: Iterate through the extensions, calculate the strength for each, keep track of the maximum strength and the corresponding extension. Use a loop and helper functions to count uppercase and lowercase letters. Time: O(n*m) where n is the number of extensions and m is the average length of extensions. Space: O(1). STEP 3 - EDGE CASES: Empty extensions list \u2192 return class name with no extension. Extensions with equal strength \u2192 choose the first one. Extensions with all uppercase or all lowercase letters \u2192 handle correctly. STEP 4 - IMPLEMENT: Use a loop to iterate through extensions, calculate strength using helper functions, and keep track of the strongest extension.\",\n  \"name\": \"Strongest_Extension\",\n  \"code\": \"def Strongest_Extension(class_name, extensions):\\n    if not extensions:\\n        return class_name\\n    max_strength = -float('inf')\\n    strongest = ''\\n    for ext in extensions:\\n        cap = sum(1 for c in ext if c.isupper())\\n        sm = sum(1 for c in ext if c.islower())\\n        strength = cap - sm\\n        if strength > max_strength:\\n            max_strength = strength\\n            strongest = ext\\n    return f'{class_name}.{strongest}'\"\n}"
    },
    "HumanEval/68": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a list of non-negative integers representing tree nodes. The task is to find the smallest even value in the list and return its value and index. If there are multiple nodes with the same smallest even value, return the one with the smallest index. If there are no even values or the list is empty, return an empty list. Examples show that 0 is considered even and should be included. STEP 2 - PLAN: Iterate through the list to find the smallest even value and its index. Initialize variables to track the smallest even value and its index. If a smaller even value is found, update these variables. After iteration, return the result in the specified format. Time complexity: O(n), Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return []. No even numbers \u2192 return []. All even numbers \u2192 find the smallest. Multiple smallest even values \u2192 choose the one with the smallest index. List with zero \u2192 0 is even, include it. STEP 4 - IMPLEMENT: Use a loop to iterate through the list, check if each number is even, and update the smallest even value and its index accordingly. Return the result in the specified format.",
      "name": "pluck",
      "code": "def pluck(arr):\n    smallest_even = None\n    smallest_index = -1\n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if smallest_even is None or num < smallest_even:\n                smallest_even = num\n                smallest_index = i\n    return [smallest_even, smallest_index] if smallest_even is not None else []",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a list of non-negative integers representing tree nodes. The task is to find the smallest even value in the list and return its value and index. If there are multiple nodes with the same smallest even value, return the one with the smallest index. If there are no even values or the list is empty, return an empty list. Examples show that 0 is considered even and should be included. STEP 2 - PLAN: Iterate through the list to find the smallest even value and its index. Initialize variables to track the smallest even value and its index. If a smaller even value is found, update these variables. After iteration, return the result in the specified format. Time complexity: O(n), Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return []. No even numbers \u2192 return []. All even numbers \u2192 find the smallest. Multiple smallest even values \u2192 choose the one with the smallest index. List with zero \u2192 0 is even, include it. STEP 4 - IMPLEMENT: Use a loop to iterate through the list, check if each number is even, and update the smallest even value and its index accordingly. Return the result in the specified format.\",\n  \"name\": \"pluck\",\n  \"code\": \"def pluck(arr):\\n    smallest_even = None\\n    smallest_index = -1\\n    for i, num in enumerate(arr):\\n        if num % 2 == 0:\\n            if smallest_even is None or num < smallest_even:\\n                smallest_even = num\\n                smallest_index = i\\n    return [smallest_even, smallest_index] if smallest_even is not None else []\"\n}"
    },
    "HumanEval/133": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: Input is a list of numbers (integers or floats), output is a single integer (sum of squared numbers). Need to round each number up to the nearest integer (ceiling) before squaring and summing. Examples show that both positive and negative numbers are handled, and floats are rounded up. STEP 2 - PLAN: Use the math.ceil() function to round each number up, square the result, and sum all squared values. Can use a generator expression with sum() for clean implementation. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0 (sum of nothing). Single element \u2192 square that one element. Negative numbers \u2192 ceil(-2.4) \u2192 -2, then square \u2192 4. Floats \u2192 ceil(1.4) \u2192 2, then square \u2192 4. Zero \u2192 ceil(0) \u2192 0, then square \u2192 0. STEP 4 - IMPLEMENT: Use math.ceil() to round up, square the result, and sum all values using sum() with a generator expression.",
      "name": "sum_squares",
      "code": "import math\ndef sum_squares(lst):\n    return sum(math.ceil(n)**2 for n in lst)",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a list of numbers (integers or floats), output is a single integer (sum of squared numbers). Need to round each number up to the nearest integer (ceiling) before squaring and summing. Examples show that both positive and negative numbers are handled, and floats are rounded up. STEP 2 - PLAN: Use the math.ceil() function to round each number up, square the result, and sum all squared values. Can use a generator expression with sum() for clean implementation. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0 (sum of nothing). Single element \u2192 square that one element. Negative numbers \u2192 ceil(-2.4) \u2192 -2, then square \u2192 4. Floats \u2192 ceil(1.4) \u2192 2, then square \u2192 4. Zero \u2192 ceil(0) \u2192 0, then square \u2192 0. STEP 4 - IMPLEMENT: Use math.ceil() to round up, square the result, and sum all values using sum() with a generator expression.\",\n  \"name\": \"sum_squares\",\n  \"code\": \"import math\\ndef sum_squares(lst):\\n    return sum(math.ceil(n)**2 for n in lst)\"\n}"
    },
    "HumanEval/95": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: Input is a dictionary, output is a boolean. Need to check if all keys are either lowercase or uppercase strings. Return False if dictionary is empty or contains non-string keys. Examples show mixed cases return False, uniform cases return True. STEP 2 - PLAN: First check if dictionary is empty \u2192 return False. Then check if all keys are strings \u2192 if any key is not a string, return False. Then check if all keys are lowercase or all keys are uppercase \u2192 use all() with islower() or isupper(). Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty dict \u2192 False. Dict with non-string keys \u2192 False. Mixed case keys \u2192 False. All lowercase or all uppercase \u2192 True. STEP 4 - IMPLEMENT: Implement checks in order: empty dict, non-string keys, uniform case.",
      "name": "check_dict_case",
      "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    if not all(isinstance(key, str) for key in dict.keys()):\n        return False\n    keys = list(dict.keys())\n    return all(key.islower() for key in keys) or all(key.isupper() for key in keys)",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a dictionary, output is a boolean. Need to check if all keys are either lowercase or uppercase strings. Return False if dictionary is empty or contains non-string keys. Examples show mixed cases return False, uniform cases return True. STEP 2 - PLAN: First check if dictionary is empty \u2192 return False. Then check if all keys are strings \u2192 if any key is not a string, return False. Then check if all keys are lowercase or all keys are uppercase \u2192 use all() with islower() or isupper(). Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty dict \u2192 False. Dict with non-string keys \u2192 False. Mixed case keys \u2192 False. All lowercase or all uppercase \u2192 True. STEP 4 - IMPLEMENT: Implement checks in order: empty dict, non-string keys, uniform case.\",\n  \"name\": \"check_dict_case\",\n  \"code\": \"def check_dict_case(dict):\\n    if not dict:\\n        return False\\n    if not all(isinstance(key, str) for key in dict.keys()):\\n        return False\\n    keys = list(dict.keys())\\n    return all(key.islower() for key in keys) or all(key.isupper() for key in keys)\"\n}"
    },
    "HumanEval/126": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: Input is a list of integers, output is a boolean indicating if the list is sorted in ascending order and has no more than 1 duplicate of any number. Examples show that single-element lists are sorted, strictly increasing lists are sorted, lists with duplicates are sorted only if no number appears more than twice, and unsorted lists return False. STEP 2 - PLAN: First, check if the list is sorted by comparing it to its sorted version. Then, count the frequency of each number and ensure no number appears more than twice. Use collections.Counter for counting. Time: O(n log n) for sorting, O(n) for counting. Space: O(n) for the Counter. STEP 3 - EDGE CASES: Empty list \u2192 return True (vacuously sorted). Single-element list \u2192 return True. List with all duplicates \u2192 return False if any number appears more than twice. List with negative numbers \u2192 problem says assume no negatives. STEP 4 - IMPLEMENT: Compare the list to its sorted version and use Counter to check for duplicates.",
      "name": "is_sorted",
      "code": "from collections import Counter\ndef is_sorted(lst):\n    if lst == sorted(lst):\n        counts = Counter(lst)\n        return all(count <= 2 for count in counts.values())\n    return False",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a list of integers, output is a boolean indicating if the list is sorted in ascending order and has no more than 1 duplicate of any number. Examples show that single-element lists are sorted, strictly increasing lists are sorted, lists with duplicates are sorted only if no number appears more than twice, and unsorted lists return False. STEP 2 - PLAN: First, check if the list is sorted by comparing it to its sorted version. Then, count the frequency of each number and ensure no number appears more than twice. Use collections.Counter for counting. Time: O(n log n) for sorting, O(n) for counting. Space: O(n) for the Counter. STEP 3 - EDGE CASES: Empty list \u2192 return True (vacuously sorted). Single-element list \u2192 return True. List with all duplicates \u2192 return False if any number appears more than twice. List with negative numbers \u2192 problem says assume no negatives. STEP 4 - IMPLEMENT: Compare the list to its sorted version and use Counter to check for duplicates.\",\n  \"name\": \"is_sorted\",\n  \"code\": \"from collections import Counter\\ndef is_sorted(lst):\\n    if lst == sorted(lst):\\n        counts = Counter(lst)\\n        return all(count <= 2 for count in counts.values())\\n    return False\"\n}"
    }
  },
  "passed": 9,
  "total": 9,
  "pass_rate": "9/9 (100.0%)"
}