{
  "model": "deepseek/deepseek-chat-v3",
  "prompt_type": "stepwise_cot",
  "system_prompt": "You are an expert programmer. For each problem, follow this step-by-step reasoning process:\n\nSTEP 1 - UNDERSTAND: Read the problem carefully\n- What are the inputs and outputs?\n- What do the examples show?\n- What are the constraints?\n\nSTEP 2 - PLAN: Design your solution\n- What algorithm or approach should you use?\n- What data structures do you need?\n- What's the time/space complexity?\n\nSTEP 3 - EDGE CASES: Identify special cases\n- Empty inputs, single elements, duplicates\n- Boundary values (0, negative, maximum)\n- Invalid or unusual inputs\n\nSTEP 4 - IMPLEMENT: Write clean, correct code\n- Handle all edge cases\n- Use clear variable names\n- Ensure logic is sound\n\nEXAMPLE - Problem: Find the sum of all even numbers in a list\n{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a list of integers, output is a single integer (the sum). Need to identify even numbers (divisible by 2) and add them together. Example: [1,2,3,4] \u2192 2+4 = 6. STEP 2 - PLAN: Use a filtering approach - iterate through the list, check each number with modulo operator (n % 2 == 0), sum the filtered results. Can use generator expression with sum() for clean implementation. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0 (sum of nothing). No even numbers \u2192 return 0. All even numbers \u2192 sum all. List with zero \u2192 0 is even, include it. Negative evens \u2192 -2, -4 are even, include them. STEP 4 - IMPLEMENT: Use sum() with generator expression for clarity. The condition 'n % 2 == 0' handles all cases including negatives and zero correctly.\",\n  \"name\": \"sum_evens\",\n  \"code\": \"def sum_evens(numbers):\n    return sum(n for n in numbers if n % 2 == 0)\"\n}\n\nAfter your reasoning, output ONLY this JSON format (no markdown fences, no extra text):\n{\n  \"thinking\": \"<your step-by-step reasoning>\",\n  \"name\": \"<function_name>\",\n  \"code\": \"<complete_python_function_code_only>\"\n\n\nCRITICAL: The \"code\" field must contain ONLY the function code, no thinking or comments.",
  "tests": {
    "HumanEval/129": {
      "passed": false,
      "error": "name 'heapq' is not defined",
      "thinking": "STEP 1 - UNDERSTAND: The input is a grid (N x N) and an integer k. Each cell has a unique value from 1 to N*N. The goal is to find the lexicographically smallest path of length k, where a path is a sequence of cells connected by edges. The output is the list of values along this path. STEP 2 - PLAN: Use a BFS approach to explore all possible paths of length k. Since we need the lexicographically smallest path, we should prioritize paths that start with the smallest possible value. We can use a priority queue (heap) to always expand the smallest path first. STEP 3 - EDGE CASES: k=1 \u2192 return the smallest value in the grid. k=N*N \u2192 return the sorted list of all values. Grid with only one cell \u2192 return that cell's value. STEP 4 - IMPLEMENT: Implement BFS with a heap to ensure we always expand the smallest path first. Track visited cells to avoid cycles.",
      "name": "minPath",
      "code": "import heapq\ndef minPath(grid, k):\n    n = len(grid)\n    heap = []\n    for i in range(n):\n        for j in range(n):\n            heapq.heappush(heap, ([grid[i][j]], i, j))\n    while heap:\n        path, x, y = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\n    return []",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a grid (N x N) and an integer k. Each cell has a unique value from 1 to N*N. The goal is to find the lexicographically smallest path of length k, where a path is a sequence of cells connected by edges. The output is the list of values along this path. STEP 2 - PLAN: Use a BFS approach to explore all possible paths of length k. Since we need the lexicographically smallest path, we should prioritize paths that start with the smallest possible value. We can use a priority queue (heap) to always expand the smallest path first. STEP 3 - EDGE CASES: k=1 \u2192 return the smallest value in the grid. k=N*N \u2192 return the sorted list of all values. Grid with only one cell \u2192 return that cell's value. STEP 4 - IMPLEMENT: Implement BFS with a heap to ensure we always expand the smallest path first. Track visited cells to avoid cycles.\",\n  \"name\": \"minPath\",\n  \"code\": \"import heapq\\ndef minPath(grid, k):\\n    n = len(grid)\\n    heap = []\\n    for i in range(n):\\n        for j in range(n):\\n            heapq.heappush(heap, ([grid[i][j]], i, j))\\n    while heap:\\n        path, x, y = heapq.heappop(heap)\\n        if len(path) == k:\\n            return path\\n        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n            nx, ny = x + dx, y + dy\\n            if 0 <= nx < n and 0 <= ny < n:\\n                heapq.heappush(heap, (path + [grid[nx][ny]], nx, ny))\\n    return []\"\n}"
    },
    "HumanEval/69": {
      "passed": false,
      "error": "name 'Counter' is not defined",
      "thinking": "STEP 1 - UNDERSTAND: The input is a non-empty list of positive integers. We need to find the greatest integer where its frequency in the list is greater than or equal to the integer itself. If no such integer exists, return -1. Examples show that for [4,1,2,2,3,1], 2 appears twice (frequency >= 2), so return 2. For [1,2,2,3,3,3,4,4,4], 3 appears three times (frequency >= 3), so return 3. For [5,5,4,4,4], neither 5 nor 4 meet the condition, so return -1. STEP 2 - PLAN: First, count the frequency of each integer using a dictionary. Then, iterate through the dictionary to find integers where frequency >= value. Track the maximum such integer. If none found, return -1. Time: O(n) for counting frequencies, O(m) for checking conditions (m is number of unique integers). Space: O(m) for frequency dictionary. STEP 3 - EDGE CASES: Single element list \u2192 check if frequency (1) >= value. All elements same \u2192 check if frequency >= value. No valid integer \u2192 return -1. STEP 4 - IMPLEMENT: Use collections.Counter for frequency counting. Iterate through frequency dictionary, check condition, track maximum valid integer.",
      "name": "search",
      "code": "from collections import Counter\ndef search(lst):\n    freq = Counter(lst)\n    max_val = -1\n    for num, count in freq.items():\n        if count >= num and num > max_val:\n            max_val = num\n    return max_val",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a non-empty list of positive integers. We need to find the greatest integer where its frequency in the list is greater than or equal to the integer itself. If no such integer exists, return -1. Examples show that for [4,1,2,2,3,1], 2 appears twice (frequency >= 2), so return 2. For [1,2,2,3,3,3,4,4,4], 3 appears three times (frequency >= 3), so return 3. For [5,5,4,4,4], neither 5 nor 4 meet the condition, so return -1. STEP 2 - PLAN: First, count the frequency of each integer using a dictionary. Then, iterate through the dictionary to find integers where frequency >= value. Track the maximum such integer. If none found, return -1. Time: O(n) for counting frequencies, O(m) for checking conditions (m is number of unique integers). Space: O(m) for frequency dictionary. STEP 3 - EDGE CASES: Single element list \u2192 check if frequency (1) >= value. All elements same \u2192 check if frequency >= value. No valid integer \u2192 return -1. STEP 4 - IMPLEMENT: Use collections.Counter for frequency counting. Iterate through frequency dictionary, check condition, track maximum valid integer.\",\n  \"name\": \"search\",\n  \"code\": \"from collections import Counter\\ndef search(lst):\\n    freq = Counter(lst)\\n    max_val = -1\\n    for num, count in freq.items():\\n        if count >= num and num > max_val:\\n            max_val = num\\n    return max_val\"\n}"
    },
    "HumanEval/141": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a string representing a filename. The output is 'Yes' if the filename meets all validity conditions, otherwise 'No'. Conditions: no more than 3 digits, exactly one dot, non-empty prefix starting with Latin letter, suffix must be 'txt', 'exe', or 'dll'. Examples show basic cases. STEP 2 - PLAN: We'll break this into steps: 1) Count digits with isdigit(), 2) Split on '.' and verify exactly two parts, 3) Check prefix is non-empty and starts with a letter (isalpha()), 4) Check suffix matches allowed extensions. Time: O(n) since we scan the string multiple times. Space: O(1). STEP 3 - EDGE CASES: No dot \u2192 invalid. Multiple dots \u2192 invalid. Empty name \u2192 invalid. Name starts with digit \u2192 invalid. More than 3 digits \u2192 invalid. Wrong extension \u2192 invalid. Just '.' \u2192 invalid. STEP 4 - IMPLEMENT: Implement checks in order, returning 'No' if any fail early. Use list operations or regex could be alternative.",
      "name": "file_name_check",
      "code": "def file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    parts = file_name.split('.')\n    if len(parts) != 2 or not parts[0] or not parts[1]:\n        return 'No'\n    prefix, suffix = parts\n    if sum(c.isdigit() for c in file_name) > 3:\n        return 'No'\n    if not prefix[0].isalpha():\n        return 'No'\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a string representing a filename. The output is 'Yes' if the filename meets all validity conditions, otherwise 'No'. Conditions: no more than 3 digits, exactly one dot, non-empty prefix starting with Latin letter, suffix must be 'txt', 'exe', or 'dll'. Examples show basic cases. STEP 2 - PLAN: We'll break this into steps: 1) Count digits with isdigit(), 2) Split on '.' and verify exactly two parts, 3) Check prefix is non-empty and starts with a letter (isalpha()), 4) Check suffix matches allowed extensions. Time: O(n) since we scan the string multiple times. Space: O(1). STEP 3 - EDGE CASES: No dot \u2192 invalid. Multiple dots \u2192 invalid. Empty name \u2192 invalid. Name starts with digit \u2192 invalid. More than 3 digits \u2192 invalid. Wrong extension \u2192 invalid. Just '.' \u2192 invalid. STEP 4 - IMPLEMENT: Implement checks in order, returning 'No' if any fail early. Use list operations or regex could be alternative.\",\n  \"name\": \"file_name_check\",\n  \"code\": \"def file_name_check(file_name):\\n    if file_name.count('.') != 1:\\n        return 'No'\\n    parts = file_name.split('.')\\n    if len(parts) != 2 or not parts[0] or not parts[1]:\\n        return 'No'\\n    prefix, suffix = parts\\n    if sum(c.isdigit() for c in file_name) > 3:\\n        return 'No'\\n    if not prefix[0].isalpha():\\n        return 'No'\\n    if suffix not in ['txt', 'exe', 'dll']:\\n        return 'No'\\n    return 'Yes'\"\n}"
    },
    "HumanEval/94": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a list of integers. The output is the sum of the digits of the largest prime number in the list. Examples show that we need to first identify the largest prime number and then sum its digits. STEP 2 - PLAN: First, create a helper function to check if a number is prime. Then, iterate through the list to find the largest prime. Finally, sum the digits of that prime number. Time complexity: O(n * sqrt(m)), where n is the number of elements in the list and m is the largest number in the list. Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0. No prime numbers \u2192 return 0. All numbers are prime \u2192 find the largest and sum its digits. List with zero \u2192 zero is not prime, ignore it. Negative numbers \u2192 primes are positive, ignore negatives. STEP 4 - IMPLEMENT: Implement the helper function to check for primes. Iterate through the list to find the largest prime. Sum the digits of the largest prime and return the result.",
      "name": "skjkasdkd",
      "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    largest_prime = 0\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n    return sum(int(digit) for digit in str(largest_prime)) if largest_prime else 0",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a list of integers. The output is the sum of the digits of the largest prime number in the list. Examples show that we need to first identify the largest prime number and then sum its digits. STEP 2 - PLAN: First, create a helper function to check if a number is prime. Then, iterate through the list to find the largest prime. Finally, sum the digits of that prime number. Time complexity: O(n * sqrt(m)), where n is the number of elements in the list and m is the largest number in the list. Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0. No prime numbers \u2192 return 0. All numbers are prime \u2192 find the largest and sum its digits. List with zero \u2192 zero is not prime, ignore it. Negative numbers \u2192 primes are positive, ignore negatives. STEP 4 - IMPLEMENT: Implement the helper function to check for primes. Iterate through the list to find the largest prime. Sum the digits of the largest prime and return the result.\",\n  \"name\": \"skjkasdkd\",\n  \"code\": \"def skjkasdkd(lst):\\n    def is_prime(n):\\n        if n < 2:\\n            return False\\n        for i in range(2, int(n ** 0.5) + 1):\\n            if n % i == 0:\\n                return False\\n        return True\\n    largest_prime = 0\\n    for num in lst:\\n        if is_prime(num) and num > largest_prime:\\n            largest_prime = num\\n    return sum(int(digit) for digit in str(largest_prime)) if largest_prime else 0\"\n}"
    },
    "HumanEval/153": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a class name (string) and a list of extensions (strings). The output is a string combining the class name and the strongest extension, formatted as 'ClassName.StrongestExtensionName'. The strength of an extension is calculated as (number of uppercase letters) - (number of lowercase letters). If multiple extensions have the same strength, the first one in the list is chosen. Example: 'Slices' with ['SErviNGSliCes', 'Cheese', 'StuFfed'] \u2192 'Slices.SErviNGSliCes' (strength = -1). STEP 2 - PLAN: Iterate through the extensions, calculate the strength for each by counting uppercase and lowercase letters, and keep track of the strongest one. Use a loop and string methods like isupper() and islower() to count letters. Time: O(n*m) where n is the number of extensions and m is the average length of extensions. Space: O(1). STEP 3 - EDGE CASES: Empty extensions list \u2192 return 'ClassName.' (though problem implies list is non-empty). Extensions with equal strength \u2192 choose the first one. Extensions with all uppercase or all lowercase letters. STEP 4 - IMPLEMENT: Use a loop to calculate strength for each extension, compare and track the strongest one, and return the formatted result.",
      "name": "Strongest_Extension",
      "code": "def Strongest_Extension(class_name, extensions):\n    strongest = None\n    max_strength = -float('inf')\n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest = ext\n    return f'{class_name}.{strongest}'",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a class name (string) and a list of extensions (strings). The output is a string combining the class name and the strongest extension, formatted as 'ClassName.StrongestExtensionName'. The strength of an extension is calculated as (number of uppercase letters) - (number of lowercase letters). If multiple extensions have the same strength, the first one in the list is chosen. Example: 'Slices' with ['SErviNGSliCes', 'Cheese', 'StuFfed'] \u2192 'Slices.SErviNGSliCes' (strength = -1). STEP 2 - PLAN: Iterate through the extensions, calculate the strength for each by counting uppercase and lowercase letters, and keep track of the strongest one. Use a loop and string methods like isupper() and islower() to count letters. Time: O(n*m) where n is the number of extensions and m is the average length of extensions. Space: O(1). STEP 3 - EDGE CASES: Empty extensions list \u2192 return 'ClassName.' (though problem implies list is non-empty). Extensions with equal strength \u2192 choose the first one. Extensions with all uppercase or all lowercase letters. STEP 4 - IMPLEMENT: Use a loop to calculate strength for each extension, compare and track the strongest one, and return the formatted result.\",\n  \"name\": \"Strongest_Extension\",\n  \"code\": \"def Strongest_Extension(class_name, extensions):\\n    strongest = None\\n    max_strength = -float('inf')\\n    for ext in extensions:\\n        cap = sum(1 for c in ext if c.isupper())\\n        sm = sum(1 for c in ext if c.islower())\\n        strength = cap - sm\\n        if strength > max_strength:\\n            max_strength = strength\\n            strongest = ext\\n    return f'{class_name}.{strongest}'\"\n}"
    },
    "HumanEval/68": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: The input is a list of non-negative integers representing tree nodes. The task is to find the smallest even value and return it along with its index in the format [value, index]. If there are multiple nodes with the same smallest even value, return the one with the smallest index. If there are no even values or the list is empty, return an empty list. Examples show that zero is considered even and should be included. STEP 2 - PLAN: Iterate through the list to find the smallest even value and its index. Initialize variables to track the smallest even value and its index. For each element, check if it is even and smaller than the current smallest even value. Update the tracked values accordingly. If no even values are found, return an empty list. Time complexity: O(n), Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return []. No even numbers \u2192 return []. All even numbers \u2192 find the smallest. Multiple smallest evens \u2192 return the first one. Zero is present \u2192 include it as the smallest even. STEP 4 - IMPLEMENT: Initialize variables to track the smallest even value and its index. Iterate through the list, updating the tracked values when a smaller even value is found. Return the result based on the tracked values.",
      "name": "pluck",
      "code": "def pluck(arr):\n    smallest_even = None\n    smallest_index = -1\n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if smallest_even is None or num < smallest_even:\n                smallest_even = num\n                smallest_index = i\n    return [smallest_even, smallest_index] if smallest_even is not None else []",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: The input is a list of non-negative integers representing tree nodes. The task is to find the smallest even value and return it along with its index in the format [value, index]. If there are multiple nodes with the same smallest even value, return the one with the smallest index. If there are no even values or the list is empty, return an empty list. Examples show that zero is considered even and should be included. STEP 2 - PLAN: Iterate through the list to find the smallest even value and its index. Initialize variables to track the smallest even value and its index. For each element, check if it is even and smaller than the current smallest even value. Update the tracked values accordingly. If no even values are found, return an empty list. Time complexity: O(n), Space complexity: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return []. No even numbers \u2192 return []. All even numbers \u2192 find the smallest. Multiple smallest evens \u2192 return the first one. Zero is present \u2192 include it as the smallest even. STEP 4 - IMPLEMENT: Initialize variables to track the smallest even value and its index. Iterate through the list, updating the tracked values when a smaller even value is found. Return the result based on the tracked values.\",\n  \"name\": \"pluck\",\n  \"code\": \"def pluck(arr):\\n    smallest_even = None\\n    smallest_index = -1\\n    for i, num in enumerate(arr):\\n        if num % 2 == 0:\\n            if smallest_even is None or num < smallest_even:\\n                smallest_even = num\\n                smallest_index = i\\n    return [smallest_even, smallest_index] if smallest_even is not None else []\"\n}"
    },
    "HumanEval/133": {
      "passed": false,
      "error": "name 'math' is not defined",
      "thinking": "STEP 1 - UNDERSTAND: Input is a list of numbers (integers or floats), output is a single integer (the sum of squared numbers). Need to round each number up to the nearest integer (ceiling) before squaring and summing. Examples show that both positive and negative numbers are handled, and floats are rounded up. STEP 2 - PLAN: Use the math.ceil() function to round each number up. Then square the rounded numbers and sum them. Can use a generator expression with sum() for clean implementation. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0 (sum of nothing). Single element \u2192 square that one element. Negative numbers \u2192 ceiling of -2.4 is -2. Floats \u2192 1.4 \u2192 2. Zero \u2192 ceiling of 0 is 0. STEP 4 - IMPLEMENT: Use math.ceil() to round up, square the result, and sum all squared values.",
      "name": "sum_squares",
      "code": "import math\ndef sum_squares(lst):\n    return sum(math.ceil(n)**2 for n in lst)",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a list of numbers (integers or floats), output is a single integer (the sum of squared numbers). Need to round each number up to the nearest integer (ceiling) before squaring and summing. Examples show that both positive and negative numbers are handled, and floats are rounded up. STEP 2 - PLAN: Use the math.ceil() function to round each number up. Then square the rounded numbers and sum them. Can use a generator expression with sum() for clean implementation. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty list \u2192 return 0 (sum of nothing). Single element \u2192 square that one element. Negative numbers \u2192 ceiling of -2.4 is -2. Floats \u2192 1.4 \u2192 2. Zero \u2192 ceiling of 0 is 0. STEP 4 - IMPLEMENT: Use math.ceil() to round up, square the result, and sum all squared values.\",\n  \"name\": \"sum_squares\",\n  \"code\": \"import math\\ndef sum_squares(lst):\\n    return sum(math.ceil(n)**2 for n in lst)\"\n}"
    },
    "HumanEval/95": {
      "passed": true,
      "error": "",
      "thinking": "STEP 1 - UNDERSTAND: Input is a dictionary, output is a boolean. Need to check if all keys are either lowercase strings or all are uppercase strings. Return False if dictionary is empty or contains non-string keys. Examples show mixed cases return False, consistent cases return True. STEP 2 - PLAN: First check if dictionary is empty \u2192 return False. Then check if all keys are strings \u2192 if not, return False. Then check if all keys are lowercase or all are uppercase. Can use all() with islower() or isupper() for each key. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty dict \u2192 False. Non-string keys \u2192 False. Mixed case keys \u2192 False. All lowercase \u2192 True. All uppercase \u2192 True. STEP 4 - IMPLEMENT: First check for empty dict. Then check if all keys are strings. Then check if all keys are lowercase or all are uppercase using all() with islower() and isupper().",
      "name": "check_dict_case",
      "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    if not all(isinstance(key, str) for key in dict.keys()):\n        return False\n    keys = list(dict.keys())\n    return all(key.islower() for key in keys) or all(key.isupper() for key in keys)",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a dictionary, output is a boolean. Need to check if all keys are either lowercase strings or all are uppercase strings. Return False if dictionary is empty or contains non-string keys. Examples show mixed cases return False, consistent cases return True. STEP 2 - PLAN: First check if dictionary is empty \u2192 return False. Then check if all keys are strings \u2192 if not, return False. Then check if all keys are lowercase or all are uppercase. Can use all() with islower() or isupper() for each key. Time: O(n), Space: O(1). STEP 3 - EDGE CASES: Empty dict \u2192 False. Non-string keys \u2192 False. Mixed case keys \u2192 False. All lowercase \u2192 True. All uppercase \u2192 True. STEP 4 - IMPLEMENT: First check for empty dict. Then check if all keys are strings. Then check if all keys are lowercase or all are uppercase using all() with islower() and isupper().\",\n  \"name\": \"check_dict_case\",\n  \"code\": \"def check_dict_case(dict):\\n    if not dict:\\n        return False\\n    if not all(isinstance(key, str) for key in dict.keys()):\\n        return False\\n    keys = list(dict.keys())\\n    return all(key.islower() for key in keys) or all(key.isupper() for key in keys)\"\n}"
    },
    "HumanEval/126": {
      "passed": false,
      "error": "This prints if this assert fails 7 (good for debugging!)",
      "thinking": "STEP 1 - UNDERSTAND: Input is a list of integers, output is a boolean indicating if the list is sorted in ascending order. Additionally, if there are more than 1 duplicate of the same number, return False. Examples show that single-element lists are considered sorted, and lists with duplicates are only valid if duplicates appear consecutively and no more than once. STEP 2 - PLAN: First, check if the list has more than one duplicate of any number by comparing the length of the list to the length of a set created from the list. If the difference is greater than 1, return False. Then, check if the list is sorted by comparing it to a sorted version of itself. Time: O(n log n) due to sorting, Space: O(n) for the sorted list. STEP 3 - EDGE CASES: Single-element list \u2192 return True. Empty list \u2192 return True. List with all identical elements \u2192 return False if count > 1. List with negative numbers \u2192 not handled as per constraints. STEP 4 - IMPLEMENT: Use a set to check for duplicates and compare the list to its sorted version.",
      "name": "is_sorted",
      "code": "def is_sorted(lst):\n    if len(lst) - len(set(lst)) > 1:\n        return False\n    return lst == sorted(lst)",
      "raw_response": "{\n  \"thinking\": \"STEP 1 - UNDERSTAND: Input is a list of integers, output is a boolean indicating if the list is sorted in ascending order. Additionally, if there are more than 1 duplicate of the same number, return False. Examples show that single-element lists are considered sorted, and lists with duplicates are only valid if duplicates appear consecutively and no more than once. STEP 2 - PLAN: First, check if the list has more than one duplicate of any number by comparing the length of the list to the length of a set created from the list. If the difference is greater than 1, return False. Then, check if the list is sorted by comparing it to a sorted version of itself. Time: O(n log n) due to sorting, Space: O(n) for the sorted list. STEP 3 - EDGE CASES: Single-element list \u2192 return True. Empty list \u2192 return True. List with all identical elements \u2192 return False if count > 1. List with negative numbers \u2192 not handled as per constraints. STEP 4 - IMPLEMENT: Use a set to check for duplicates and compare the list to its sorted version.\",\n  \"name\": \"is_sorted\",\n  \"code\": \"def is_sorted(lst):\\n    if len(lst) - len(set(lst)) > 1:\\n        return False\\n    return lst == sorted(lst)\"\n}"
    }
  },
  "passed": 5,
  "total": 9,
  "pass_rate": "5/9 (55.6%)"
}